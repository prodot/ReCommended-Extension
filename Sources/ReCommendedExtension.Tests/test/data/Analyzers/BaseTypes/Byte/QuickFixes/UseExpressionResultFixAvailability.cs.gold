using System;

namespace Test
{
    public class Bytes
    {
        public void Clamp(byte number)
        {
            var result11 = |byte.Clamp(number, 1, 0x01)|(0);

            byte result21 = |byte.Clamp(number, 1, 0x01)|(1);

            var result31 = |byte.Clamp(number, 0, 255)|(2);
            var result32 = |byte.Clamp(1, 0, 255)|(3);

            byte result41 = |byte.Clamp(number, 0, 255)|(4);
            byte result42 = |byte.Clamp(1, 0, 255)|(5);

            var result51 = |Math.Clamp(number, (byte)1, (byte)1)|(6);
            var result52 = |Math.Clamp(number, byte.MinValue, byte.MaxValue)|(7);
        }

        public void DivRem(byte left)
        {
            var result11 = |byte.DivRem(0, 10)|(8);

            (byte, byte) result21 = |byte.DivRem(0, 10)|(9);

            (byte quotient, byte remainder) result32 = |byte.DivRem(0, 10)|(10);

            var result71 = |Math.DivRem((byte)0, (byte)10)|(11);
        }

        public void Equals(byte number)
        {
            var result = |number.Equals(null)|(12);
        }

        public void GetTypeCode(byte number)
        {
            var result = |number.GetTypeCode()|(13);
        }

        public void Max()
        {
            var result1 = |byte.Max(10, 0x0A)|(14);

            byte result2 = |byte.Max(10, 0x0A)|(15);

            var result3 = |Math.Max((byte)10, (byte)10)|(16);
        }

        public void Min()
        {
            var result1 = |byte.Min(10, 0x0A)|(17);

            byte result2 = |byte.Min(10, 0x0A)|(18);

            var result3 = |Math.Min((byte)10, (byte)10)|(19);
        }

        public void RotateLeft(byte n)
        {
            const int c = 1;

            var result11 = |byte.RotateLeft(n, 0)|(20);
            var result12 = |byte.RotateLeft(1, 0)|(21);
            var result13 = |byte.RotateLeft(1 + 1, 0)|(22);
            var result14 = |byte.RotateLeft(c, 0)|(23);

            byte result21 = |byte.RotateLeft(n, 0)|(24);
            byte result22 = |byte.RotateLeft(1, 0)|(25);
            byte result23 = |byte.RotateLeft(1 + 1, 0)|(26);
            byte result24 = |byte.RotateLeft(c, 0)|(27);
        }

        public void RotateRight(byte n)
        {
            const int c = 1;

            var result11 = |byte.RotateRight(n, 0)|(28);
            var result12 = |byte.RotateRight(1, 0)|(29);
            var result13 = |byte.RotateRight(1 + 1, 0)|(30);
            var result14 = |byte.RotateRight(c, 0)|(31);

            byte result21 = |byte.RotateRight(n, 0)|(32);
            byte result22 = |byte.RotateRight(1, 0)|(33);
            byte result23 = |byte.RotateRight(1 + 1, 0)|(34);
            byte result24 = |byte.RotateRight(c, 0)|(35);
        }
    }
}
------------------------------------------------
0: The expression is always 1.
QUICKFIXES:
Replace with '(byte)0x01'
Replace with '(byte)1'
1: The expression is always 1.
QUICKFIXES:
Replace with '0x01'
Replace with '1'
2: The expression is always the same as the first argument.
QUICKFIXES:
Replace with 'number'
3: The expression is always the same as the first argument.
QUICKFIXES:
Replace with '(byte)1'
4: The expression is always the same as the first argument.
QUICKFIXES:
Replace with 'number'
5: The expression is always the same as the first argument.
QUICKFIXES:
Replace with '1'
6: The expression is always 1.
QUICKFIXES:
Replace with '(byte)1'
7: The expression is always the same as the first argument.
QUICKFIXES:
Replace with 'number'
8: The expression is always (0, 0).
QUICKFIXES:
Replace with '(Quotient: (byte)0, Remainder: (byte)0)'
9: The expression is always (0, 0).
QUICKFIXES:
Replace with '(0, 0)'
10: The expression is always (0, 0).
QUICKFIXES:
Replace with '(0, 0)'
11: The expression is always (0, 0).
QUICKFIXES:
Replace with '(Quotient: (byte)0, Remainder: (byte)0)'
12: The expression is always false.
QUICKFIXES:
Replace with 'false'
13: The expression is always TypeCode.Byte.
QUICKFIXES:
Replace with 'TypeCode.Byte'
14: The expression is always 10.
QUICKFIXES:
Replace with '(byte)0x0A'
Replace with '(byte)10'
15: The expression is always 10.
QUICKFIXES:
Replace with '0x0A'
Replace with '10'
16: The expression is always 10.
QUICKFIXES:
Replace with '(byte)10'
17: The expression is always 10.
QUICKFIXES:
Replace with '(byte)0x0A'
Replace with '(byte)10'
18: The expression is always 10.
QUICKFIXES:
Replace with '0x0A'
Replace with '10'
19: The expression is always 10.
QUICKFIXES:
Replace with '(byte)10'
20: The expression is always the same as the first argument.
QUICKFIXES:
Replace with 'n'
21: The expression is always the same as the first argument.
QUICKFIXES:
Replace with '(byte)1'
22: The expression is always the same as the first argument.
QUICKFIXES:
Replace with '(byte)(1 + 1)'
23: The expression is always the same as the first argument.
QUICKFIXES:
Replace with '(byte)c'
24: The expression is always the same as the first argument.
QUICKFIXES:
Replace with 'n'
25: The expression is always the same as the first argument.
QUICKFIXES:
Replace with '1'
26: The expression is always the same as the first argument.
QUICKFIXES:
Replace with '1 + 1'
27: The expression is always the same as the first argument.
QUICKFIXES:
Replace with 'c'
28: The expression is always the same as the first argument.
QUICKFIXES:
Replace with 'n'
29: The expression is always the same as the first argument.
QUICKFIXES:
Replace with '(byte)1'
30: The expression is always the same as the first argument.
QUICKFIXES:
Replace with '(byte)(1 + 1)'
31: The expression is always the same as the first argument.
QUICKFIXES:
Replace with '(byte)c'
32: The expression is always the same as the first argument.
QUICKFIXES:
Replace with 'n'
33: The expression is always the same as the first argument.
QUICKFIXES:
Replace with '1'
34: The expression is always the same as the first argument.
QUICKFIXES:
Replace with '1 + 1'
35: The expression is always the same as the first argument.
QUICKFIXES:
Replace with 'c'
